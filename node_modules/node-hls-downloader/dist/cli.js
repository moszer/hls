#!/usr/bin/env node
'use strict';

var commander = require('commander');
var index = require('./index');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var commander__namespace = /*#__PURE__*/_interopNamespace(commander);

var version = "2.2.0";

function parseHeaders(value, previous) {
    const pos = value.indexOf(":");
    if (pos > 0) {
        const key = value.substr(0, pos).trim();
        previous[key] = value.substr(pos + 1).trim();
    }
    return previous;
}
class ArgumentParser {
    parse(argv) {
        const args = new commander__namespace.Command();
        // Setup
        args
            .version(version)
            .usage("[options] <url>")
            .option("--live", "Download the stream as a live feed", false)
            .option("--ffmpeg-merge", "Merge TS segments using FFMPEG", false)
            .option("--ffmpeg-path", "Path to the FFMPEG binary", "ffmpeg")
            .option("--segments-dir <dir>", "Where the TS segments will be stored")
            .option("--merged-segments-file <file>", "Location of the merged TS segments file")
            .option("-c, --concurrency <threads>", "How many threads to use for segments download", (v) => parseInt(v, 10), 1)
            .option("-q, --quality <quality>", "Stream quality when possible (worst, best, or max bandwidth)", "best")
            .option("-o, --output-file <file>", "Target file to download the stream to")
            .option("-h, --header <header>", "Header to pass to the HTTP requests", parseHeaders, {})
            .option("--quiet", "Don't show trivial log messages", false)
            .parse(argv);
        const opts = args.opts();
        // Varlidate a few arguments
        if (args.args.length !== 1) {
            console.error("You must provide exactly one URL");
            return false;
        }
        if (opts.quality && !["worst", "best"].includes(opts.quality) && !parseInt(opts.quality, 10)) {
            console.error("Invalid quality provided:", opts.quality);
            return false;
        }
        if (!opts.outputFile) {
            console.error("You must provide an output file");
            return false;
        }
        // Read arguments to variables
        return {
            concurrency: opts.concurrency,
            fromEnd: opts.fromEnd,
            httpHeaders: opts.header,
            live: opts.live,
            mergeUsingFfmpeg: opts.ffmpegMerge,
            ffmpegPath: opts.ffmpegPath,
            mergedSegmentsFile: opts.mergedSegmentsFile,
            outputFile: opts.outputFile,
            quality: opts.quality,
            segmentsDir: opts.segmentsDir,
            streamUrl: args.args[0],
            logger: opts.quiet ? {
                log: () => { },
                error: console.error,
            } : undefined,
        };
    }
}

(async () => {
    // Parse CLI arguments
    const argumentParser = new ArgumentParser();
    const config = argumentParser.parse(process.argv);
    if (!config) {
        return;
    }
    // Start download
    await index.download(config);
})();
