'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs$1 = require('fs-extra');
var os = require('os');
var path = require('path');
var url = require('url');
var m3u8 = require('m3u8-parser');
var PQueue = require('p-queue');
var fs = require('fs');
var axios = require('axios');
var cp = require('child_process');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var fs__namespace$1 = /*#__PURE__*/_interopNamespace(fs$1);
var os__namespace = /*#__PURE__*/_interopNamespace(os);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var m3u8__namespace = /*#__PURE__*/_interopNamespace(m3u8);
var PQueue__default = /*#__PURE__*/_interopDefaultLegacy(PQueue);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var cp__namespace = /*#__PURE__*/_interopNamespace(cp);

async function get(url, headers) {
    const response = await axios__default["default"].get(url, { responseType: "text", headers });
    return response.data;
}
async function download$1(url, file, headers) {
    const response = await axios__default["default"](url, { responseType: "stream", headers });
    const stream = response.data.pipe(fs__namespace.createWriteStream(file));
    return new Promise((resolve, reject) => {
        stream.on("finish", resolve);
        stream.on("error", reject);
    });
}

class ChunksDownloader {
    constructor(logger, playlistUrl, concurrency, segmentDirectory, httpHeaders) {
        this.logger = logger;
        this.playlistUrl = playlistUrl;
        this.concurrency = concurrency;
        this.segmentDirectory = segmentDirectory;
        this.httpHeaders = httpHeaders;
        this.queue = new PQueue__default["default"]({
            concurrency: this.concurrency,
        });
    }
    start() {
        return new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            this.queue.add(() => this.refreshPlayList());
        });
    }
    async loadPlaylist() {
        const response = await get(this.playlistUrl, this.httpHeaders);
        const parser = new m3u8__namespace.Parser();
        parser.push(response);
        parser.end();
        return parser.manifest;
    }
    async downloadSegment(segmentUrl) {
        // Get filename from URL
        const question = segmentUrl.indexOf("?");
        let filename = question > 0 ? segmentUrl.substr(0, question) : segmentUrl;
        const slash = filename.lastIndexOf("/");
        filename = filename.substr(slash + 1);
        // Download file
        await download$1(segmentUrl, path__namespace.join(this.segmentDirectory, filename), this.httpHeaders);
        this.logger.log("Received:", segmentUrl);
    }
}

class ChunksLiveDownloader extends ChunksDownloader {
    constructor(logger, playlistUrl, concurrency, fromEnd, segmentDirectory, timeoutDuration = 60, playlistRefreshInterval = 5, httpHeaders) {
        super(logger, playlistUrl, concurrency, segmentDirectory, httpHeaders);
        this.fromEnd = fromEnd;
        this.timeoutDuration = timeoutDuration;
        this.playlistRefreshInterval = playlistRefreshInterval;
    }
    async refreshPlayList() {
        const playlist = await this.loadPlaylist();
        const interval = playlist.targetDuration || this.playlistRefreshInterval;
        const segments = playlist.segments.map((s) => new url.URL(s.uri, this.playlistUrl).href);
        this.refreshHandle = setTimeout(() => this.refreshPlayList(), interval * 1000);
        let toLoad = [];
        if (!this.lastSegment) {
            toLoad = segments.slice(segments.length - this.fromEnd);
        }
        else {
            const index = segments.indexOf(this.lastSegment);
            if (index < 0) {
                this.logger.error("Could not find last segment in playlist");
                toLoad = segments;
            }
            else if (index === segments.length - 1) {
                this.logger.log("No new segments since last check");
                return;
            }
            else {
                toLoad = segments.slice(index + 1);
            }
        }
        this.lastSegment = toLoad[toLoad.length - 1];
        for (const uri of toLoad) {
            this.logger.log("Queued:", uri);
            this.queue.add(() => this.downloadSegment(uri));
        }
        // Timeout after X seconds without new segment
        if (this.timeoutHandle) {
            clearTimeout(this.timeoutHandle);
        }
        this.timeoutHandle = setTimeout(() => this.timeout(), this.timeoutDuration * 1000);
    }
    timeout() {
        this.logger.log("No new segment for a while, stopping");
        if (this.refreshHandle) {
            clearTimeout(this.refreshHandle);
        }
        this.resolve();
    }
}

class ChunksStaticDownloader extends ChunksDownloader {
    constructor(logger, playlistUrl, concurrency, segmentDirectory, httpHeaders) {
        super(logger, playlistUrl, concurrency, segmentDirectory, httpHeaders);
    }
    async refreshPlayList() {
        const playlist = await this.loadPlaylist();
        const segments = playlist.segments.map((s) => new url.URL(s.uri, this.playlistUrl).href);
        this.logger.log(`Queueing ${segments.length} segment(s)`);
        for (const uri of segments) {
            this.queue.add(() => this.downloadSegment(uri));
        }
        this.queue.onIdle().then(() => this.finished());
    }
    finished() {
        this.logger.log("All segments received, stopping");
        this.resolve();
    }
}

async function spawnFfmpeg(logger, ffmpegPath, argss) {
    return new Promise((resolve, reject) => {
        logger.log("Spawning FFMPEG", ffmpegPath, argss.join(" "));
        const ffmpeg = cp__namespace.spawn(ffmpegPath, argss);
        ffmpeg.on("message", (msg) => logger.log("ffmpeg message:", msg));
        ffmpeg.on("error", (msg) => {
            logger.error("ffmpeg error:", msg);
            reject(msg);
        });
        ffmpeg.on("close", (status) => {
            if (status !== 0) {
                logger.error(`ffmpeg closed with status ${status}`);
                reject(`ffmpeg closed with status ${status}`);
            }
            else {
                resolve();
            }
        });
        ffmpeg.stdout.on("data", (data) => logger.log(`ffmpeg stdout: ${data}`));
        ffmpeg.stderr.on("data", (data) => logger.log(`ffmpeg stderr: ${data}`));
    });
}
async function mergeChunks(logger, ffmpegPath, segments, outputFile) {
    // Temporary files
    const segmentsFile = "ffmpeg-input.txt";
    // Generate a FFMPEG input file
    const inputStr = segments.map((f) => `file '${f}'\n`).join("");
    fs__namespace.writeFileSync(segmentsFile, inputStr);
    // Merge chunks
    const mergeArgs = [
        "-y",
        "-loglevel", "warning",
        "-f", "concat",
        "-i", segmentsFile,
        "-c", "copy",
        outputFile,
    ];
    await spawnFfmpeg(logger, ffmpegPath, mergeArgs);
    // Clear temporary file
    fs__namespace.unlinkSync(segmentsFile);
}
async function transmuxTsToMp4(logger, ffmpegPath, inputFile, outputFile) {
    await spawnFfmpeg(logger, ffmpegPath, [
        "-y",
        "-loglevel", "warning",
        "-i", inputFile,
        "-c", "copy",
        "-bsf:a", "aac_adtstoasc",
        outputFile,
    ]);
}

function copyToStream(inFile, outStream) {
    return new Promise((resolve, reject) => {
        fs__namespace
            .createReadStream(inFile)
            .on("error", reject)
            .on("end", resolve)
            .pipe(outStream, { end: false });
    });
}
async function mergeFiles(files, outputFile) {
    const outStream = fs__namespace.createWriteStream(outputFile);
    const ret = new Promise((resolve, reject) => {
        outStream.on("finish", resolve);
        outStream.on("error", reject);
    });
    for (const file of files) {
        await copyToStream(file, outStream);
    }
    outStream.end();
    return ret;
}

class StreamChooser {
    constructor(logger, streamUrl, httpHeaders) {
        this.logger = logger;
        this.streamUrl = streamUrl;
        this.httpHeaders = httpHeaders;
    }
    async load() {
        const streams = await get(this.streamUrl, this.httpHeaders);
        const parser = new m3u8__namespace.Parser();
        parser.push(streams);
        parser.end();
        this.manifest = parser.manifest;
        return (this.manifest.segments && this.manifest.segments.length > 0)
            || (this.manifest.playlists && this.manifest.playlists.length > 0)
            || false;
    }
    isMaster() {
        if (!this.manifest) {
            throw Error("You need to call 'load' before 'isMaster'");
        }
        return this.manifest.playlists && this.manifest.playlists.length > 0 || false;
    }
    getPlaylistUrl(maxBandwidth) {
        if (!this.manifest) {
            throw Error("You need to call 'load' before 'getPlaylistUrl'");
        }
        // If we already provided a playlist URL
        if (this.manifest.segments && this.manifest.segments.length > 0) {
            return this.streamUrl;
        }
        // You need a quality parameter with a master playlist
        if (!maxBandwidth) {
            this.logger.error("You need to provide a quality with a master playlist");
            return false;
        }
        // Find the most relevant playlist
        if (this.manifest.playlists && this.manifest.playlists.length > 0) {
            let compareFn;
            if (maxBandwidth === "best") {
                compareFn = (prev, current) => (prev.attributes.BANDWIDTH > current.attributes.BANDWIDTH) ? prev : current;
            }
            else if (maxBandwidth === "worst") {
                compareFn = (prev, current) => (prev.attributes.BANDWIDTH > current.attributes.BANDWIDTH) ? current : prev;
            }
            else {
                compareFn = (prev, current) => (prev.attributes.BANDWIDTH > current.attributes.BANDWIDTH || current.attributes.BANDWIDTH > maxBandwidth) ? prev : current;
            }
            const uri = this.manifest.playlists.reduce(compareFn).uri;
            return new url.URL(uri, this.streamUrl).href;
        }
        this.logger.error("No stream or playlist found in URL:", this.streamUrl);
        return false;
    }
}

function buildLogger(logger) {
    if (logger === undefined) {
        return console;
    }
    if (logger === null) {
        return buildLogger(() => { });
    }
    if (typeof logger === "function") {
        return {
            log: logger,
            error: logger,
        };
    }
    return logger;
}

async function download(config) {
    const logger = buildLogger(config.logger);
    // Temporary files
    const runId = Date.now();
    const mergedSegmentsFile = config.mergedSegmentsFile || os__namespace.tmpdir() + "/hls-downloader/" + runId + ".ts";
    const segmentsDir = config.segmentsDir || os__namespace.tmpdir() + "/hls-downloader/" + runId + "/";
    const ffmpegPath = config.ffmpegPath || "ffmpeg";
    // Create target directory
    fs__namespace$1.mkdirpSync(path__namespace.dirname(mergedSegmentsFile));
    fs__namespace$1.mkdirpSync(segmentsDir);
    // Choose proper stream
    const streamChooser = new StreamChooser(logger, config.streamUrl, config.httpHeaders);
    if (!await streamChooser.load()) {
        return;
    }
    const playlistUrl = streamChooser.getPlaylistUrl(config.quality);
    if (!playlistUrl) {
        return;
    }
    // Start download
    const chunksDownloader = config.live
        ? new ChunksLiveDownloader(logger, playlistUrl, config.concurrency || 1, config.fromEnd || 9999, segmentsDir, undefined, undefined, config.httpHeaders) : new ChunksStaticDownloader(logger, playlistUrl, config.concurrency || 1, segmentsDir, config.httpHeaders);
    await chunksDownloader.start();
    // Get all segments
    const segments = fs__namespace$1.readdirSync(segmentsDir).map((f) => segmentsDir + f);
    segments.sort((a, b) => {
        return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
    });
    // Merge TS files
    const mergeFunction = config.mergeUsingFfmpeg
        ? (segments, merged) => mergeChunks(logger, ffmpegPath, segments, merged)
        : mergeFiles;
    await mergeFunction(segments, mergedSegmentsFile);
    // Transmux
    await transmuxTsToMp4(logger, ffmpegPath, mergedSegmentsFile, config.outputFile);
    // Delete temporary files
    fs__namespace$1.remove(segmentsDir);
    fs__namespace$1.remove(mergedSegmentsFile);
}

exports.download = download;
